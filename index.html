<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blunderfish Chess</title>
    <style>
        :root { --dark: #769656; --light: #eeeed2; --sel: #f6f669; --check: #ff5e5e; --white: #fff; --black: #1b1917; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #312e2b; color: white; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        .game-layout { display: flex; gap: 20px; align-items: flex-start; margin-top: 20px; flex-wrap: wrap; justify-content: center; }
        .eval-container { width: 12px; height: 480px; background: #000; border: 2px solid #555; position: relative; display: flex; flex-direction: column-reverse; border-radius: 4px; }
        #eval-bar { width: 100%; background: #fff; transition: height 0.6s; height: 50%; }
        #board { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px); border: 5px solid #222; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .sq { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; font-size: 45px; cursor: pointer; user-select: none; }
        .light { background: var(--light); } .dark { background: var(--dark); }
        .selected { background: var(--sel) !important; } .in-check { background: var(--check) !important; border-radius: 50%; }
        .p-white { color: var(--white); text-shadow: 1px 1px 3px #000; } .p-black { color: var(--black); }
        .sidebar { background: #262421; padding: 20px; border-radius: 8px; width: 280px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        #move-log { height: 180px; overflow-y: auto; background: #1b1917; padding: 10px; font-family: monospace; border: 1px solid #444; margin-bottom: 10px; border-radius: 4px; }
        .move-entry { display: flex; justify-content: space-between; padding: 3px 5px; border-bottom: 1px solid #333; }
        .leaderboard-box { border: 1px solid #d4af37; background: rgba(212, 175, 55, 0.05); padding: 10px; border-radius: 4px; margin-top: 10px; }
        .leaderboard-title { color: #d4af37; font-size: 11px; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; }
        .r-brilliant { color: #00ebff; font-weight: bold; } .r-blunder { color: #ff3b3b; font-weight: bold; }
        select, button { width: 100%; padding: 10px; border-radius: 4px; border: none; font-weight: bold; cursor: pointer; margin-top: 5px; }
        select { background: #444; color: white; } button { background: #769656; color: white; }
        .btn-resign { background: #a64d4d; margin-top: 10px; }
    </style>
</head>
<body>

    <h2 style="margin:0; color:#769656;">BLUNDERFISH <span style="font-weight:100; color:#fff;">v1.0</span></h2>

    <div class="game-layout">
        <div class="eval-container"><div id="eval-bar"></div></div>
        <div id="board"></div>
        <div class="sidebar">
            <div id="turn-status" style="text-align:center; padding:8px; background:#fff; color:#000; font-weight:bold; border-radius:4px; margin-bottom:10px;">WHITE'S TURN</div>
            <select id="difficulty">
                <option value="loser" selected>üêü BLUNDERFISH (-1800)</option>
                <option value="0">Brainless (~100)</option>
                <option value="1">Beginner (~250)</option>
                <option value="4">Master (~1900)</option>
            </select>
            <div id="move-log"></div>
            <div class="leaderboard-box">
                <div class="leaderboard-title">üèÜ 1800+ Hall of Fame</div>
                <div id="leaderboard-list" style="font-size: 12px;"></div>
            </div>
            <button onclick="location.reload()" style="margin-top:15px;">New Game</button>
            <button onclick="resignGame()" class="btn-resign">Resign</button>
        </div>
    </div>

<script>
    const glyphs = { 'p': '‚ôü', 'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö', 'P': '‚ôü', 'R': '‚ôú', 'N': '‚ôû', 'B': '‚ôù', 'Q': '‚ôõ', 'K': '‚ôö' };
    let board = [['r','n','b','q','k','b','n','r'],['p','p','p','p','p','p','p','p'],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['P','P','P','P','P','P','P','P'],['R','N','B','Q','K','B','N','R']];
    let turn = 'W', selected = null, moveHistory = [];
    const weights = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
    const leaderboard = JSON.parse(localStorage.getItem('blunderfish_hof')) || [];

    function render() {
        const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
        const checking = isCheck(turn, board);
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                const sq = document.createElement('div');
                sq.className = `sq ${(r+c)%2===0 ? 'light' : 'dark'}`;
                if(selected?.r===r && selected?.c===c) sq.classList.add('selected');
                const p = board[r][c];
                if(checking && p.toUpperCase()==='K' && ((turn==='W'&&p==='K')||(turn==='B'&&p==='k'))) sq.classList.add('in-check');
                if(p) { sq.innerHTML = glyphs[p]; sq.classList.add(p===p.toUpperCase()?'p-white':'p-black'); }
                sq.onclick = () => onSquareClick(r, c);
                boardEl.appendChild(sq);
            }
        }
        updateEvalBar();
    }

    function evaluateBoard(b) {
        let score = 0;
        const mode = document.getElementById('difficulty').value;
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                const p = b[r][c]; if(!p) continue;
                const isWhite = p === p.toUpperCase();
                let val = weights[p.toLowerCase()];
                // Blunderfish Logic: Rewards itself for hanging pieces
                if (mode === 'loser' && !isWhite) {
                    for(let tr=0; tr<8; tr++) for(let tc=0; tc<8; tc++)
                        if(validateMove(tr, tc, r, c, b, false)) val -= 5000;
                }
                score += isWhite ? -val : val;
            }
        }
        return score;
    }

    function onSquareClick(r, c) {
        if (turn === 'B') return;
        if (selected) {
            if (validateMove(selected.r, selected.c, r, c, board, true)) executeMove(selected.r, selected.c, r, c);
            else { selected = (board[r][c] && board[r][c] === board[r][c].toUpperCase()) ? {r, c} : null; render(); }
        } else if (board[r][c] && board[r][c] === board[r][c].toUpperCase()) { selected = {r, c}; render(); }
    }

    function executeMove(fr, fc, tr, tc) {
        const p = board[fr][fc];
        const notation = (p.toLowerCase()==='p'?'':p.toUpperCase()) + String.fromCharCode(97+fc) + (8-fr) + "‚Üí" + String.fromCharCode(97+tc) + (8-tr);
        let rating = { sym: "", cls: "" };
        if (turn === 'W') {
            const pre = evaluateBoard(board);
            const best = minimax(3, board, false, -Infinity, Infinity, false).score;
            board[tr][tc] = p; board[fr][fc] = '';
            const post = evaluateBoard(board);
            const d = post - best;
            if (d === 0) rating = { sym: "!!", cls: "r-brilliant" };
            else if (d < -300) rating = { sym: "??", cls: "r-blunder" };
        } else {
            board[tr][tc] = p; board[fr][fc] = '';
        }
        moveHistory.push(notation);
        document.getElementById('move-log').innerHTML = `<div class="move-entry"><span>${notation}</span><span class="${rating.cls}">${rating.sym}</span></div>` + document.getElementById('move-log').innerHTML;
        turn = turn==='W'?'B':'W'; 
        document.getElementById('turn-status').innerText = turn === 'W' ? "WHITE'S TURN" : "BLACK'S TURN";
        selected = null; render();
        if (turn === 'B') setTimeout(aiAction, 500);
        checkGameOver();
    }

    function aiAction() {
        const mode = document.getElementById('difficulty').value;
        let best;
        if (mode === "0") {
            const m = getAllMoves(board, 'B');
            best = { move: m[Math.floor(Math.random()*m.length)] };
        } else {
            const depth = mode === 'loser' ? 3 : parseInt(mode);
            best = minimax(depth, board, true, -Infinity, Infinity, mode === 'loser');
        }
        if (best.move) executeMove(best.move.fr, best.move.fc, best.move.tr, best.move.tc);
    }

    function minimax(depth, b, isMax, alpha, beta, isLoser) {
        if (depth === 0) return { score: evaluateBoard(b) };
        const moves = getAllMoves(b, isMax ? 'B' : 'W');
        if (moves.length === 0) return { score: isMax ? -50000 : 50000 };
        let bestMove = null;
        let bestScore = (isMax ^ isLoser) ? -Infinity : Infinity;
        for (const m of moves) {
            const temp = b.map(row => [...row]);
            temp[m.tr][m.tc] = temp[m.fr][m.fc]; temp[m.fr][m.fc] = '';
            const res = minimax(depth-1, temp, !isMax, alpha, beta, isLoser);
            if (isMax ^ isLoser) {
                if(res.score > bestScore){bestScore=res.score; bestMove=m;}
                alpha = Math.max(alpha, bestScore);
            } else {
                if(res.score < bestScore){bestScore=res.score; bestMove=m;}
                beta = Math.min(beta, bestScore);
            }
            if (beta <= alpha) break;
        }
        return { score: bestScore, move: bestMove };
    }

    function getAllMoves(b, side) {
        const moves = [];
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) 
            if (b[r][c] && (b[r][c]===b[r][c].toUpperCase())===(side==='W'))
                for(let tr=0; tr<8; tr++) for(let tc=0; tc<8; tc++) 
                    if (validateMove(r, c, tr, tc, b, true)) moves.push({fr:r, fc:c, tr, tc});
        return moves;
    }

    function validateMove(fr, fc, tr, tc, b, s) {
        const p = b[fr][fc]; if(!p) return false;
        const type = p.toLowerCase(), target = b[tr][tc], isW = p===p.toUpperCase();
        if (target !== '' && (target===target.toUpperCase()) === isW) return false;
        const dr = tr-fr, dc = tc-fc;
        let legal = false;
        if (type==='p') {
            const dir = isW?-1:1;
            if (fc===tc && target==='') { if(dr===dir || (dr===2*dir && fr===(isW?6:1) && b[fr+dir][fc]==='')) legal=true; }
            else if (Math.abs(dc)===1 && dr===dir && target!=='') legal=true;
        } else if (type==='n') legal = (Math.abs(dr)===2 && Math.abs(dc)===1) || (Math.abs(dr)===1 && Math.abs(dc)===2);
        else if (type==='k') legal = Math.abs(dr)<=1 && Math.abs(dc)<=1;
        else if (['r','b','q'].includes(type)) {
            if ((type==='r' && (dr===0 || dc===0)) || (type==='b' && Math.abs(dr)===Math.abs(dc)) || (type==='q' && (dr===0 || dc===0 || Math.abs(dr)===Math.abs(dc)))) {
                const sr = dr===0?0:dr/Math.abs(dr), sc = dc===0?0:dc/Math.abs(dc);
                let cr=fr+sr, cc=fc+sc; legal=true;
                while(cr!==tr || cc!==tc) { if(b[cr][cc]!==''){legal=false;break;} cr+=sr; cc+=sc; }
            }
        }
        if (legal && s) {
            const t = b.map(row => [...row]); t[tr][tc] = t[fr][fc]; t[fr][fc] = '';
            if (isCheck(isW?'W':'B', t)) return false;
        }
        return legal;
    }

    function isCheck(side, b) {
        let kr, kc;
        for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(b[r][c]===(side==='W'?'K':'k')) {kr=r;kc=c;}
        if(kr===undefined) return false;
        for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
            const p = b[r][c]; if(p && (p===p.toUpperCase())!==(side==='W')) if(validateMove(r,c,kr,kc,b,false)) return true;
        }
        return false;
    }

    function checkGameOver() {
        const m = getAllMoves(board, turn);
        if (m.length === 0) {
            const win = isCheck(turn, board);
            if (win && turn === 'B' && document.getElementById('difficulty').value === "4") {
                const name = prompt("MASTER DEFEATED! Name for Hall of Fame:");
                if(name) { leaderboard.push({name, moves: moveHistory.length}); leaderboard.sort((a,b)=>a.moves-b.moves); localStorage.setItem('blunderfish_hof', JSON.stringify(leaderboard)); updateLeaderboardUI(); }
            }
            alert(win ? (turn==='W'?"AI WINS (Traditional)":"YOU WIN (Traditional)") : "DRAW");
        }
    }

    function resignGame() { alert("YOU RESIGNED. Blunderfish claims a chaotic victory!"); location.reload(); }
    function updateEvalBar() { const s = evaluateBoard(board); document.getElementById('eval-bar').style.height = Math.max(5, Math.min(95, 50-(s/100))) + "%"; }
    function updateLeaderboardUI() {
        const list = document.getElementById('leaderboard-list');
        list.innerHTML = leaderboard.slice(0,5).map((e,i)=> `<div>#${i+1} ${e.name} (${e.moves}m)</div>`).join('') || "No masters yet.";
    }
    updateLeaderboardUI(); render();
</script>
</body>
</html>
