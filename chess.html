<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gemini Chess: Grandmaster Coach</title>
    <style>
        :root { --dark: #769656; --light: #eeeed2; --sel: #f6f669; --check: #ff5e5e; --white: #fff; --black: #1b1917; }
        body { font-family: 'Segoe UI', sans-serif; background: #312e2b; color: white; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        .game-layout { display: flex; gap: 20px; align-items: flex-start; margin-top: 20px; }
        .eval-container { width: 12px; height: 480px; background: #000; border: 2px solid #555; position: relative; display: flex; flex-direction: column-reverse; border-radius: 4px; }
        #eval-bar { width: 100%; background: #fff; transition: height 0.6s; height: 50%; }
        #board { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px); border: 5px solid #222; position: relative; }
        .sq { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; font-size: 45px; cursor: pointer; user-select: none; }
        .light { background: var(--light); } .dark { background: var(--dark); }
        .selected { background: var(--sel) !important; } .in-check { background: var(--check) !important; border-radius: 50%; }
        .p-white { color: var(--white); text-shadow: 1px 1px 3px #000; } .p-black { color: var(--black); }
        .sidebar { background: #262421; padding: 20px; border-radius: 8px; width: 280px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        #move-log { height: 220px; overflow-y: auto; background: #1b1917; padding: 10px; font-family: monospace; border: 1px solid #444; margin-bottom: 10px; font-size: 14px; border-radius: 4px; }
        .move-entry { display: flex; justify-content: space-between; padding: 4px 5px; border-bottom: 1px solid #333; align-items: center; }
        /* Rating Colors */
        .r-brilliant { color: #00ebff; text-shadow: 0 0 5px #00ebff; } /* !! */
        .r-great { color: #69b5ff; } /* ! */
        .r-good { color: #95bb4a; } /* ✓ */
        .r-risky { color: #e6e6e6; font-style: italic; } /* !? */
        .r-dubious { color: #fff1ad; } /* ?! */
        .r-bad { color: #ffb342; } /* ? */
        .r-blunder { color: #ff3b3b; font-weight: bold; } /* ?? */
        .r-miss { color: #ff9d00; border: 1px solid #ff9d00; padding: 0 2px; } /* - */
        
        .control-group { margin-bottom: 15px; background: #3c3934; padding: 10px; border-radius: 4px; }
        select, button { width: 100%; padding: 10px; border-radius: 4px; margin-bottom: 5px; cursor: pointer; border: none; font-weight: bold; }
        select { background: #555; color: white; }
        button { background: #769656; color: white; }
    </style>
</head>
<body>

    <div class="game-layout">
        <div class="eval-container"><div id="eval-bar"></div></div>
        <div id="board"></div>
        <div class="sidebar">
            <div id="turn-status" style="padding:10px; text-align:center; font-weight:bold; background:#fff; color:#000; border-radius:4px; margin-bottom:10px;">WHITE'S TURN</div>
            <div class="control-group">
                <select id="difficulty">
                    <option value="0">Brainless (~100 Elo)</option>
                    <option value="1">Beginner (~250 Elo)</option>
                    <option value="2">Intermediate (~800 Elo)</option>
                    <option value="3" selected>Advanced (~1200 Elo)</option>
                    <option value="4">Master (~1900 Elo)</option>
                </select>
            </div>
            <div id="move-log"></div>
            <button onclick="location.reload()">Reset Game</button>
        </div>
    </div>

<script>
    const glyphs = { 'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'P': '♟', 'R': '♜', 'N': '♞', 'B': '♝', 'Q': '♛', 'K': '♚' };
    let board = [['r','n','b','q','k','b','n','r'],['p','p','p','p','p','p','p','p'],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['P','P','P','P','P','P','P','P'],['R','N','B','Q','K','B','N','R']];
    let turn = 'W', selected = null;
    const weights = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
    const pst = [
        [0,0,0,0,0,0,0,0], [5,10,10,-20,-20,10,10,5], [5,-5,-10,0,0,-10,-5,5], [0,0,0,25,25,0,0,0],
        [0,0,0,25,25,0,0,0], [5,-5,-10,0,0,-10,-5,5], [5,10,10,-20,-20,10,10,5], [0,0,0,0,0,0,0,0]
    ];

    function render() {
        const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
        const checking = isCheck(turn, board);
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                const sq = document.createElement('div');
                sq.className = `sq ${(r+c)%2===0 ? 'light' : 'dark'}`;
                if(selected?.r===r && selected?.c===c) sq.classList.add('selected');
                const p = board[r][c];
                if(checking && p.toUpperCase()==='K' && ((turn==='W'&&p==='K')||(turn==='B'&&p==='k'))) sq.classList.add('in-check');
                if(p) { sq.innerHTML = glyphs[p]; sq.classList.add(p===p.toUpperCase()?'p-white':'p-black'); }
                sq.onclick = () => onSquareClick(r, c);
                boardEl.appendChild(sq);
            }
        }
        updateEvalBar();
    }

    function evaluateBoard(b) {
        let score = 0;
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                const p = b[r][c]; if(!p) continue;
                let val = weights[p.toLowerCase()] + pst[r][c];
                score += (p === p.toUpperCase()) ? -val : val;
            }
        }
        return score;
    }

    function onSquareClick(r, c) {
        if (turn === 'B') return;
        const piece = board[r][c];
        if (selected) {
            if (validateMove(selected.r, selected.c, r, c, board, true)) executeMove(selected.r, selected.c, r, c);
            else { selected = (piece && piece === piece.toUpperCase()) ? {r, c} : null; render(); }
        } else if (piece && piece === piece.toUpperCase()) { selected = {r, c}; render(); }
    }

    function executeMove(fr, fc, tr, tc) {
        const p = board[fr][fc];
        const notation = (p.toLowerCase()==='p'?'':p.toUpperCase()) + String.fromCharCode(97+fc) + (8-fr) + "→" + String.fromCharCode(97+tc) + (8-tr);
        
        let rating = { sym: "", cls: "" };
        if (turn === 'W') {
            const preEval = evaluateBoard(board);
            const bestRes = minimax(3, board, false, -Infinity, Infinity);
            board[tr][tc] = p; board[fr][fc] = '';
            const postEval = evaluateBoard(board);
            rating = rateMove(preEval, postEval, bestRes.score);
        } else {
            board[tr][tc] = p; board[fr][fc] = '';
        }

        document.getElementById('move-log').innerHTML = `<div class="move-entry"><span>${notation}</span><span class="${rating.cls}">${rating.sym}</span></div>` + document.getElementById('move-log').innerHTML;
        turn = turn==='W'?'B':'W';
        selected = null; render();
        if (turn === 'B') setTimeout(aiAction, 500);
    }

    function rateMove(pre, post, best) {
        const diff = post - best; // Negative means worse than best
        const winShift = post - pre; // Change in eval
        
        if (diff === 0) return { sym: "!!", cls: "r-brilliant" };
        if (diff > -15) return { sym: "!", cls: "r-great" };
        if (diff > -40) return { sym: "✓", cls: "r-good" };
        if (winShift > 100 && diff < -100) return { sym: "!?", cls: "r-risky" }; // Good shift but missed better
        if (diff > -100) return { sym: "?!", cls: "r-dubious" };
        if (pre < -200 && post > 0) return { sym: "-", cls: "r-miss" }; // You were winning, now you aren't
        if (diff > -300) return { sym: "?", cls: "r-bad" };
        return { sym: "??", cls: "r-blunder" };
    }

    function aiAction() {
        const diff = document.getElementById('difficulty').value;
        let best;
        if (diff === "0") {
            const moves = getAllMoves(board, 'B');
            best = { move: moves[Math.floor(Math.random()*moves.length)] };
        } else {
            best = minimax(parseInt(diff), board, true, -Infinity, Infinity);
        }
        if (best.move) executeMove(best.move.fr, best.move.fc, best.move.tr, best.move.tc);
    }

    function minimax(depth, b, isMax, alpha, beta) {
        if (depth === 0) return { score: evaluateBoard(b) };
        const moves = getAllMoves(b, isMax ? 'B' : 'W');
        if (moves.length === 0) return { score: isMax ? -20000 : 20000 };
        let bestMove = null; let bestScore = isMax ? -Infinity : Infinity;
        for (const m of moves) {
            const temp = b.map(row => [...row]);
            temp[m.tr][m.tc] = temp[m.fr][m.fc]; temp[m.fr][m.fc] = '';
            const res = minimax(depth-1, temp, !isMax, alpha, beta);
            if (isMax) { if(res.score > bestScore){bestScore=res.score; bestMove=m;} alpha=Math.max(alpha, bestScore); }
            else { if(res.score < bestScore){bestScore=res.score; bestMove=m;} beta=Math.min(beta, bestScore); }
            if (beta <= alpha) break;
        }
        return { score: bestScore, move: bestMove };
    }

    function getAllMoves(b, side) {
        const moves = [];
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) 
            if (b[r][c] && (b[r][c]===b[r][c].toUpperCase())===(side==='W'))
                for(let tr=0; tr<8; tr++) for(let tc=0; tc<8; tc++) 
                    if (validateMove(r, c, tr, tc, b, true)) moves.push({fr:r, fc:c, tr, tc});
        return moves;
    }

    function validateMove(fr, fc, tr, tc, b, safety) {
        const p = b[fr][fc]; if (!p) return false;
        const type = p.toLowerCase(), target = b[tr][tc], isWhite = p===p.toUpperCase();
        const dr = tr-fr, dc = tc-fc;
        if (target !== '' && (target===target.toUpperCase()) === isWhite) return false;
        let legal = false;
        if (type==='p') {
            const dir = isWhite ? -1 : 1;
            if (fc===tc && target==='') {
                if (dr===dir) legal = true;
                if (dr===2*dir && fr===(isWhite?6:1) && b[fr+dir][fc]==='') legal = true;
            } else if (Math.abs(dc)===1 && dr===dir && target!=='') legal = true;
        } else if (type==='n') legal = (Math.abs(dr)===2 && Math.abs(dc)===1) || (Math.abs(dr)===1 && Math.abs(dc)===2);
        else if (type==='k') legal = Math.abs(dr)<=1 && Math.abs(dc)<=1;
        else if (['r','b','q'].includes(type)) {
            if ((type==='r' && (dr===0 || dc===0)) || (type==='b' && Math.abs(dr)===Math.abs(dc)) || (type==='q' && (dr===0 || dc===0 || Math.abs(dr)===Math.abs(dc)))) {
                const sr = dr===0?0:dr/Math.abs(dr), sc = dc===0?0:dc/Math.abs(dc);
                let cr = fr+sr, cc = fc+sc; legal = true;
                while(cr!==tr || cc!==tc) { if(b[cr][cc]!==''){legal=false;break;} cr+=sr; cc+=sc; }
            }
        }
        if (legal && safety) {
            const temp = b.map(row => [...row]); temp[tr][tc] = temp[fr][fc]; temp[fr][fc] = '';
            if (isCheck(isWhite?'W':'B', temp)) return false;
        }
        return legal;
    }

    function isCheck(side, b) {
        let kr, kc;
        for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(b[r][c]===(side==='W'?'K':'k')) {kr=r;kc=c;}
        if(kr===undefined) return false;
        for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
            const p = b[r][c]; if(p && (p===p.toUpperCase())!==(side==='W')) if(validateMove(r,c,kr,kc,b,false)) return true;
        }
        return false;
    }

    function updateEvalBar() {
        const score = evaluateBoard(board);
        const percent = Math.max(5, Math.min(95, 50 - (score / 40)));
        document.getElementById('eval-bar').style.height = percent + "%";
    }

    render();
</script>
</body>
</html>